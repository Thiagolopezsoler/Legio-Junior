<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rubik's Cube</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #shuffle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            background-color: #ff5722;
            color: white;
            border: none;
            cursor: pointer;
        }
        #shuffle-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <button id="shuffle-btn">Shuffle</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.121.1/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        const cubes = [];
        const cubeSize = 1; 
        const gap = 0.05;  
        let rotating = false;
        let currentAxis, selectedCubes = [];
        let rotationAngle = 0;
        let rotationSpeed = Math.PI / 90; // Velocidad de rotación
        const shuffleButton = document.getElementById('shuffle-btn');
        let movesRemaining = 0; // Contador para los movimientos

        function init() {
            // Escena y cámara
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 4, 4);

            // Renderizador
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controles para mover la cámara
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            // Crear el cubo de Rubik
            createRubikCube();

            // Evento para mezclar el cubo
            shuffleButton.addEventListener('click', shuffleCube);

            // Animar
            animate();
        }

        function createRubikCube() {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff8000, 0xffffff];

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                        const materials = colors.map(color => new THREE.MeshBasicMaterial({ color }));

                        const cube = new THREE.Mesh(geometry, materials);
                        cube.position.set(
                            (x - 1) * (cubeSize + gap),
                            (y - 1) * (cubeSize + gap),
                            (z - 1) * (cubeSize + gap)
                        );

                        scene.add(cube);
                        cubes.push(cube);
                    }
                }
            }
        }

        // Desordenar el cubo (mezclar)
        function shuffleCube() {
            // Deshabilitar el botón mientras el cubo está girando
            shuffleButton.disabled = true;
            movesRemaining = 20; // Número de movimientos que queremos realizar

            // Comenzar las rotaciones
            performMove();
        }

        function performMove() {
            if (movesRemaining > 0) {
                const axes = ['x', 'y', 'z'];
                const randomAxis = axes[Math.floor(Math.random() * axes.length)];
                const randomLayer = Math.floor(Math.random() * 3) - 1;
                rotateLayer(randomAxis, randomLayer, Math.PI / 2);
                movesRemaining--;
            } else {
                // Habilitar el botón cuando se completan las rotaciones
                shuffleButton.disabled = false;
            }
        }

        function rotateLayer(axis, layer, angle) {
            selectedCubes = cubes.filter(cube => Math.round(cube.position[axis]) === layer);
            rotating = true;
            currentAxis = axis;
            rotationAngle = angle;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (rotating) {
                let step = Math.min(rotationAngle, rotationSpeed);
                selectedCubes.forEach(cube => {
                    cube.rotateOnWorldAxis(new THREE.Vector3(currentAxis === 'x' ? 1 : 0, currentAxis === 'y' ? 1 : 0, currentAxis === 'z' ? 1 : 0), step);
                });
                rotationAngle -= step;
                if (rotationAngle <= 0) {
                    rotating = false;
                    performMove(); // Realizar el siguiente movimiento cuando termine la rotación actual
                }
            }
            renderer.render(scene, camera);
            controls.update();
        }

        init();
    </script>
</body>
</html>